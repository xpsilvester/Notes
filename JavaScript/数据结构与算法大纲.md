[TOC]



# 基础数据结构的操作实现

- 不同结构优劣对比

  - 数据结构的优劣对比指标说明：

    - 主要考虑随机访问，修改，查找3个操作。时间复杂度考虑平均情况。
      
    - 随机读取仅针对线性结构而言。对于非线性结构，封装表现出来的随机读取即为遍历序列下的随机读取,时间复杂度至少为O(nlogn),是不实用的，所以不讨论非线性结构的随机读取。
  
    - 查找为未进行排序情况下的查找，且不使用哈希表。这是为了公平起见，因为有的结构把排序摊还到了结构操作中。
  
      

    - 数组：随机读取时间复杂度为O(1)，修改时间复杂度为O(n),查找时间复杂度为O(n)。

    - 链表：随机读取时间复杂度为O(n)，修改时间复杂度为O(n),查找时间复杂度为O(n)。

    - 栈/队列：不支持随机读取。修改时间复杂度为O(1)，不支持查找，除非使用S(n)的辅助空间，此时的复杂度为O(n)。

    - 二叉树：修改的时间复杂度为O(n),查找也是O(n)。也就是遍历一遍的开销

    - 二叉堆：根据定义，仅支持修改与查找堆顶元素。修改的复杂度为O(logn),查找的复杂度为O(1)。

      - 二项堆是二叉堆的改进，斐波那契堆是二项堆的改进，具体运行时间这里不分析。

    - 二叉查找树：修改的时间复杂度为O(logn),查找的时间复杂度为O(logn)。(未退化为线性结构的情况）
    
    - 自平衡二叉查找树：基于二叉查找树的改进，改善了顺序插入情况下操作的时间复杂度，乱序插入情况下的操作复杂度则略有增加。常用的结构有红黑树，B/B+树，AVL树。还有很多其他种类，这里不讨论。
    
    - 图：不会分析，不好评价。



## 数组

### 静态数组

### 动态数组

## 栈

FILO。进栈，出栈。

可以将递归函数改写为非递归提高效率

## 队列

FIFO。进队，出队。

在BFS算法中应用较多，其他地方用的少。

## 二叉树

遍历：前序，中序，后序

遍历的递归与非递归要熟练

 其余的操作基本上都可以视为遍历的变种。

### 前序递归

三种顺序的递归版本区别只在于执行语句的位置。如下，前序在第一行，而中序在第二行，后序在第三行。与三种顺序的定义相符合，前序是根左右，中序是左根右，后序是左右根

```c++
void Tree::TraversePreOrder(struct TreeNode *p)
{
    if(p != nullptr)
    {
        std::cout<<p->key<<" ";
        TraversePreOrder(p->lchild);
        TraversePreOrder(p->rchild);
    }
}
```



### 前序非递归遍历

```c++
void Tree::TraversePreOrder()
{
   TreeNode *trav = root;
   std::stack<TreeNode*> st;
   while(trav != nullptr || !st.empty())
   {
       while(trav != nullptr)
       {
           std::cout<<trav->key<<" ";
           st.push(trav);
           trav = trav->lchild;
       }
       if(!st.empty())
       {
           trav = st.top();
           st.pop();
           trav = trav->rchild;
       }
   }
}
```

 

### 中序非递归遍历

```c++
void Tree::TraverseInOrder()                                           
{                                                        
    TreeNode *trav = root;                                            
    std::stack<TreeNode*> st;                                          
    while(trav != nullptr || !st.empty())                                    
    {                                                      
        while(trav != nullptr)                                          
        {                                                    
            st.push(trav);                                            
            trav = trav->lchild;                                         
        }                                                    
        if(!st.empty())                                             
        {                                                    
            trav = st.top();                                           
            st.pop();                                              
            std::cout<<trav->key<<" ";                                      
            trav = trav->rchild;                                         
        }                                                    
    }                                                      
}                                    
```

​                    

​                                                         

### 后序非递归遍历

```c++
void Tree::TraversePostOrder()
{
    TreeNode *trav,*pre,*topi;
    std::stack<TreeNode*> st;
    trav = root;
    pre = nullptr;
    while(trav != nullptr || !st.empty())
    {
        if(trav != nullptr)
        {
            st.push(trav);
            trav = trav->lchild;
        }
        else
        {
            topi = st.top();
            if(topi->rchild == nullptr || topi->rchild == pre)
            {
                st.pop();
                std::cout<<topi->key<<" ";
                pre = topi;
            }
            else
                trav = topi->rchild;
        }
    }
}
```



## 自平衡二叉树

### AVL树

### 红黑树

### B/B+树



## 图

### BFS

### DFS

### 最小生成树

### 最短路径

### 拓扑排序

### 关键路径

### 最大流





## 算法

### 排序

以下都以升序进行讨论（降序同理，不再另行说明）

| **排序算法**                                                 | **平均时间复杂度** | **最差时间复杂度** | **空间复杂度** | **数据对象稳定性**   |
| ------------------------------------------------------------ | ------------------ | ------------------ | -------------- | -------------------- |
| [冒泡排序](https://www.huihut.com/interview/#/Algorithm/BubbleSort.h) | O(n2)              | O(n2)              | O(1)           | 稳定                 |
| [选择排序](https://www.huihut.com/interview/#/Algorithm/SelectionSort.h) | O(n2)              | O(n2)              | O(1)           | 数组不稳定、链表稳定 |
| [插入排序](https://www.huihut.com/interview/#/Algorithm/InsertSort.h) | O(n2)              | O(n2)              | O(1)           | 稳定                 |
| [快速排序](https://www.huihut.com/interview/#/Algorithm/QuickSort.h) | O(n*log2n)         | O(n2)              | O(log2n)       | 不稳定               |
| [堆排序](https://www.huihut.com/interview/#/Algorithm/HeapSort.cpp) | O(n*log2n)         | O(n*log2n)         | O(1)           | 不稳定               |
| [归并排序](https://www.huihut.com/interview/#/Algorithm/MergeSort.h) | O(n*log2n)         | O(n*log2n)         | O(n)           | 稳定                 |
| [希尔排序](https://www.huihut.com/interview/#/Algorithm/ShellSort.h) | O(n*log2n)         | O(n2)              | O(1)           | 不稳定               |
| [计数排序](https://www.huihut.com/interview/#/Algorithm/CountSort.cpp) | O(n+m)             | O(n+m)             | O(n+m)         | 稳定                 |
| [桶排序](https://www.huihut.com/interview/#/Algorithm/BucketSort.cpp) | O(n)               | O(n)               | O(m)           | 稳定                 |
| [基数排序](https://www.huihut.com/interview/#/Algorithm/RadixSort.h) | O(k*n)             | O(n2)              |                | 稳定                 |

- 均按从小到大排列

- k：代表数值中的 “数位” 个数

- n：代表数据规模

- m：代表数据的最大值减最小值

- 来自：[wikipedia  . 排序算法](https://zh.wikipedia.org/wiki/排序算法)

- 来自 <https://www.huihut.com/interview/>

  

#### 插入排序。

  每一轮遍历未排序的序列，选择最小的数移动到已排序好的序列后面。

  ##### 直接插入排序

  ##### 折半插入排序

  ##### 希尔排序

  

  #### 交换排序。

  比较序列中两个元素的大小来交换位置，将较大者往序列尾部移动，较小者往头部移动。

  ##### 快速排序

  根据分区函数基数选择的不同，有不同的性能表现。有最边缘选择，三者取中，以及适合大量重复元素的选择。

  当快速排序分区长度小于5~25（选择其中一个值）之间时，选择直接插入排序可以获得更好的性能表现。

  ##### 冒泡排序

  ###### 经典冒泡排序

  ###### 改进的冒泡排序

###### 鸡尾酒排序

  

  #### 选择排序

  每一轮遍历未排序的序列，将第n轮找到的最小的数与位置n上的元素进行交换（n从0开始）

  ##### 直接选择排序

  ##### 堆排序

##### 锦标赛排序

寻找父亲及兄弟节点的思路：

i 是 节点下标，n是外部节点的个数，存在外部节点-内部节点=1的关系

- 外部节点

- - 父亲节点：parent = (i + n)/2 - 1

  - 兄弟节点：

  - - n为偶数：外部节点成对出现。i是偶数，存在右兄弟i+1;i是奇数，存在左兄弟i-1;
    - n为奇数：0号节点左兄弟是内部节点n-2,其他的节点成对出现。i是偶数，存在左兄弟i-1；i是奇数，存在右兄弟i+1。

- 内部节点

- - 父亲节点：parent = (i -      1)/2

  - 兄弟节点：

  - - n是偶数，内部节点成对出现。（除了根节点0）i是偶数，存在左兄弟i-1,i是奇数，存在右兄弟i+1。
    - n是奇数，除了最后一个内部节点n-2存在外部节点的右兄弟n-1（这里均是数组下标，内部节点与外部节点放在同一个数组中)。其余节点（除根节点）成对出现，i为偶数，存在左兄弟i-1,i为奇数，存在右兄弟i+1

  

  #### 归并排序

  适合于外部存储的排序算法，自底向上不断合并已经排序好的子区间

  

  #### 分配排序

  ##### 基数排序

  将整数按位数分割，分配到不同的容器再收集，当最后一位收集完成，排序便结束。

  ###### LSD

  （Least significant digital）。从最低位开始。

  ###### MSD

  （Most significant digital）。从最高位开始。

##### 桶排序

  将整数按照范围分割，桶内元素可以选择递归的桶排序或者其他排序算法，最后收集桶内元素。

  

#### 计数排序

  适用于范围变化较小，重复元素较多的序列的排序算法。

  1. 第一轮遍历获得最大值与最小值之差（可以同时访问两个元素来与min，max比较，这是最快的方法）分配一个统计数组。
  2. 第二轮遍历将统计数组每个元素出现的个数（存储到统计数组）。
  3. 第三轮循环将统计数组往后叠加，确定每一个元素排好序后的位置。
  4. 第四轮循环从原序列尾部向头部遍历，按照统计数组中的位置来将元素放置到新序列的相应位置。

  

  ### 查找

https://www.cnblogs.com/maybe2030/p/4715035.html



#### 顺序查找

- 无序查找算法。适合于存储结构为顺序存储或链接存储的线性表。期望时间复杂度为O(n)。



#### 二分查找

- 有序查找算法。最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；

- mid=(low+high)/2,       即mid=low+1/2*(high-low);



#### 插值查找

- 有序查找算法。基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。查找成功或者失败的时间复杂度均为O(log2(log2n))

- mid=low+(key-a[low])/(a[high]-a[low])*(high-low)



#### 斐波那契查找

- 有序查找算法。也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。

- mid = low + Fibonacci[k - 1] - 1,k为满足数列长度为n时的最小的第k个斐波那契数减一。

- 初始化时对于F[k]大于数列长度的部分，用数列最大值进行填充。这样每次分割时，总能分为F[k - 1] + F[k - 2]两部分。



#### 树表查找

- 二叉查找树。它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度（退化为单链表）。
- 平衡查找树。通过自平衡操作，避免最坏的时间复杂度。
  - AVL树
- 2-3查找树
  - 红黑树
  - B/B+树



#### 分块查找

- 有序查找算法。将n个数据元素"按块有序"划分为m块（m       ≤       n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素

- 先选取各块中的最大关键字构成一个索引表；查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。



#### 哈希查找

- 选择合适的哈希函数和冲突处理方法。用O(n)的辅助空间换取O(1)的查找效率。
  - 常用的冲突处理方法有拉链法和线性探测法。拉链法就是用链表实现，把冲突元素用指针连接起来。线性探测则是如有地址冲突，选择下一个位置。



### 深度优先搜索（DFS）

- 应用

  - 全排列的递归实现

  - 八皇后回溯解法如果不剪枝，也可以看作是一个全排列问题。只不过效率比剪枝慢很多。

  

### 分治法

- 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并

  - 实例
- 快速排序
  - 二分查找
  - 归并排序



### 回溯法

按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。通常使用递归来实现。

- 实例

- 八皇后

  - 基础解法：每一次判断每一行中与之前行不会冲突的列，传递给下一轮递归，所有的列都需要判断，执行速度较慢。
  
  - 最快解法：引入位运算，冲突的位置由竖、撇、捺决定，将下一行会冲突的位置传递给下一轮递归。大幅度减少了判断冲突的时间。
  
  
  
- 全排列
  
  - 递归实现
    
    1. 对于一个序列{A,B,C,D}，可以视为固定首位，再求剩余n-1位的全排列。
    2. start,end为序列开始与结束的下标，count为计数。当i=start时，即原序列首位不变，进行剩余位的全排列递归。循环依次替换首位。
    
    ```c++
    for(int i = start;i <= end;i++)
    {
        swap(a[start],a[i]);
        permutation(a,start + 1,end,count);
        swap(a[start],a[i]);
    }
    ```



### 动态规划

https://www.zhihu.com/question/23995189

- 将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。一个问题能否使用DP需要满足3个条件：能将大问题拆成几个小问题，且满足无后效性（未来与过去无关）、最优子结构性质（大问题的最优解可以由小问题的最优解推出）。

  - 重点是列举出状态转移方程，分解问题规模。通过空间换取时间的典型方法。

  - 实例

    1. 最长上升子序列。时间复杂度为O(n^2)，空间复杂度为O(n)。

  
  $$
  \begin{equation}f(n)=\left\{ \begin{aligned} 1 & , & n = 1 \\ 
    max\{f(n),f(i) + 1\} & , & n > 1,i = 1,2,...,n - 1 \end{aligned} \right. \end{equation}
  $$
  
    
  
    - f(i)为截断长度为i时最长上升子序列的长度。
  
    - LIS序列与sequence等长，初始化为1。记录每一个位置的LIS长度，计算完成后再遍历得到最大值。
  
      ```c++
      for(int index = 0;index < len;index++)
      {
          for(int preindex = 0;preindex < index;preindex++)
          {
              if(sequence[index] > sequence[preindex])
                  LIS[index] = std::max(LIS[index],LIS[preindex] + 1);
          }
      }
      ```
  
  
  ​    2. 剪绳子
  
  - 长度为n的绳子剪成m段，使其乘积最大(n>1,m>1)
  
  - f(n)=max{(f(i)*f(n-i)}
  
    
  
  
  3. 最长公共子序列
  4. 找硬币
  5. 切割钢条
  6. 背包问题
  7. 斐波那契数列的循环实现
  
  
  
  
### 最长回文子串。

一个回文串的子串也是回文(从中间往两边截取）



#### 动态规划

- 状态转移方程
  $$
  \begin{equation}P[i,j]=\left\{ \begin{aligned} P[i+1,j-1]& , & if(s[i] == s[j]) \\ 
    0 & , & if(s[i] != s[j]) \end{aligned} \right. \end{equation}
  $$
  
- 分配n^2的二维布尔数组，i，j表示从i到j是否为回文串。再需要一个start变量保存每次循环最长字串的起始位置，maxlen保存最长字串长度。

- 初始化i，i为true以及判断i，i+1是否为回文

- 从长度3到n开始，对字符串从头到尾分割的指定长度子串进行遍历。如果P[i+1][j-1]为回文且str[i]       == str[j]，那么P[i][j]也是回文。

- S(n^2),O(n^2)

#### 中心拓展法

- 不需要额外空间
  
- 如果字符串长度是奇数，每个字母当作中心向两边拓展。如果是偶数，以两个字母为中心向两边拓展。
  
    
  
#### manacher算法

时间复杂度为O(n)

需要对源字符串进行填充，字符两边填充#，使字符串长度变为奇数，从而统一处理奇偶情况。



### 贪婪算法

- 在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

- 实例

  1. 最长上升子序列。时间复杂度O（n·logn)，空间复杂度为O(n)。

  - 与DP不同之处在于LIS数组维护的不是原始序列所有位置的LIS，而是取得与下标等长LIS的最小序列值(序列值对应的原始序列下标亦可)。举个例子，当所有计算完成后，LIS[2]存放的是LIS长度为2时候的最小序列值。这样做的目的是尽可能使LIS的长度更长。

  - LIS序列初始化值为INT_MAX。pos初始化为0.
    
  - lowerbound实现的功能为使用二分算法找到指定大小元素的替换位置,为第一个大于指定元素的位置(LIS为顺序序列)。与顺序比较相比，最坏情况下的时间复杂度由n改善到logn。
    
    ```c++
    for(int i = 1;i < len;i++)
    {
        if(sequence[i] > LIS[pos])
            LIS[++pos] = sequence[i];
        else
        {
            LIS[lower_bound(LIS,pos,sequence[i])] = sequence[i];
        }
    }
    ```
    
    
    
  2. 剪绳子

     - n>=5时，尽可能剪长度为3的绳子，剩余长度为4时，剪成长度为2的两段。

     - 推导：当n>=5时，3\*(n-3) > 2\*(n - 2) > n。n = 4时，2*2>1*3。

       

  3. 最小生成树

  4. 哈夫曼树

     

### 位运算

- 与，或，（取反）非，异或，左移，右移
- 算术右移：有符号数的符号位补全。逻辑右移：补0。
- 常用公式                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
  - n&-n，提取n最右边的1
  - n&(n-1),等同于n^(n&-n),把n二进制表示的最右边的1置0

- 实例

  1. bitmap表示大数。
     - 原本用途是用来存放大量不重复数据，可以节约内存。
     - 建立一个int数组a。位数即为数字。例如数字76，76/32=2，位于a[2]中，bit位为76 % 32 = 12。把a[2]的12位设置为1即可(移位或运算） 

  

### 正则表达式匹配



### 斐波那契数列的快速算法

1. 由递推公式进行计算(O(logn))（也是DP，循环递推的DP为O(n））

   - F(a+b+1)=F(a+1)*F(b+1)+F(a)*F(b)

   - F(2n+1)=F(n+1)*F(n+1)+F(n)*F(n)

   - F(2n)=F(n+1)*F(n)+F(n)*F(n-1)=F(n+1)*F(n)+F(n)*(F(n+1)-F(n))

     

2. 快速矩阵乘法。由快速乘幂法导出快速矩阵乘法

   - 两个关键：矩阵快速幂，斐波那契数列的矩阵计算形式

     - 矩阵快速幂。形式与快速幂相同，由位运算进行实现。分解以2为底的幂级数形式。

     - 矩阵形式。有下图。实际计算的时候，可以发现如果假设f(0)  = 0,递推至n-1次幂可以简化运算，结果与n-2相同。
       $$
       \begin{vmatrix} f(n) \\f(n-1)\end{vmatrix}=
       \begin{vmatrix} 1 & 1\\1 & 0 \\ \end{vmatrix}
       \begin{vmatrix} f(n-1) \\f(n-2)\end{vmatrix}=
       \begin{vmatrix} 1 & 1\\1 & 0 \\ \end{vmatrix}^2
       \begin{vmatrix} f(n-2) \\f(n-3)\end{vmatrix}=...=
       \begin{vmatrix} 1 & 1\\1 & 0 \\ \end{vmatrix}^{n-2}
       \begin{vmatrix} f(2) \\f(1)\end{vmatrix}
       $$
       

3. 通项公式计算。由于存在无理数，不好用代码实现。https://www.zhihu.com/question/25217301



### 模式串匹配

#### BF算法

朴素暴力算法，写起来最快

#### KMP算法

实际应用较少。先遍历模式串，标定每一个位置的最长相等前后缀，通过尽可能地减少倒退的距离来加快与目标串匹配效率。

#### BM算法

效率最高，实际应用较多的算法。使用“坏字符规则”与“好后缀规则”，比较两者取得后移位数的最大值（原理了解了，还没有实现）

- http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html



### 全排列的字典序实现

设P是集合{1，2，……n-1，n}的一个全排列：P=P1P2……Pj-1PjPj+1……Pn（1≤P1，P2，……，Pn≤n-1）

1. 从排列的右端开始，找出第一个比右边数字小的数字的序号j，即j=max{i|Pi<Pi+1，i>j}

2. 在Pj的右边的数字中，找出所有比Pj大的数字中最小的数字Pk，即k=min{i|Pi>Pj，i>j}(即从右到左碰到的第一个,因为Pj+1…Pn是降序序列)

3. 交换Pj，Pk

4. 再将排列右端的递减部分Pj+1Pj+2……Pn倒转，因此可以得到一个新的排列P'=P1P2……Pj-1PkPn……Pj+2Pj+1。

   

### 数值计算



#### 平方根



##### 二分法

一种好的循环终止条件是区间长度小于指定值。



##### 牛顿迭代法

- 由切线方程推导出

  ![牛顿跌代法](../../../NoteBookPicture/数据结构与算法/牛顿迭代法.png)

- 实际实现时，第二步的循环终止条件应该修改为与上一次计算结果差小于精度值则退出算法。因为浮点数精度丢失，如果用求输入数与迭代数平方值的差值做终止条件，当数字较大或者精度要求过高，会进入无限循环

  

##### 卡马克快速平方根倒数

只适用于float型，倒除一次就得到平方根。

- 第一步的处理结果已经相当接近最后答案。0x5f3759df这个数字跟单精度浮点数的存储方式有关。
  
  经过一次牛顿迭代法就可以取得很高精度的结果
  
  [https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E9%80%9F%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/平方根倒数速算法)
  
  http://sandaoge.com/info/new_id/30.html

```c
float Q_rsqrt( float number )
{
    long i;
    float x2, y;
    const float threehalfs = 1.5F;
    x2 = number * 0.5F;
    y = number;
    i = * ( long * ) &y;            // evil floating point bit level hacking
    i = 0x5f3759df - ( i >> 1 );        // what the fuck?
    y = * ( float * ) &i;
    
    y = y * ( threehalfs - ( x2 * y * y ) );  // 1st iteration
//   y = y * ( threehalfs - ( x2 * y * y ) );  // 2nd iteration, this can be removed
return y;
}
```



##### 割线法

可实现一般形式的迭代法求方程根，因为牛顿法求导数的步骤实现较为复杂。
$$
x_{k+1}=x_{k}-\frac{f(x_k)}{f(x_k)-f(x_{k-1})}(x_k-x_{k-1})
$$

- 可以保存函数值，减少函数调用次数。

- 同样的，终止条件为两次计算的差值小于精度要求。

- 迭代次数会比牛顿法高一些，但是可以推广到求任意方程根。

  

#### 快速幂

- 把幂用二进制来表示的话，例如
  $$
  156_{(10)}=10011100_{(2)}
  $$
  可以把155次的乘法计算减少到8（二进制位数）+ 4（二进制表示中1的个数）的乘法次数加上8次除法运算，因为除法是除以2，可以用位运算来加速。
  $$
  A=a^{156}=a^{10011100}=a^{{2^7}*1+{2^6}*0+{2^5}*0+{2^4}*1+{2^3}*1+{2^2}*1+{2^1}*0+{2^0}*0}\\
  =(a^{{2^7}*1})*(a^{{2^6}*0})*(a^{{2^5}*0})*(a^{{2^4}*1})*(a^{{2^3}*1})*(a^{{2^2}*1})*(a^{{2^1}*0})*(a^{{2^0}*0})\\
  \begin{align}=(a^{{2^7}})*(a^{{2^4}})*(a^{{2^3}})*(a^{{2^2}})\end{align}
  $$

```c
long long int fun( int a, int b ) 
{
    long long int r = 1;
    int base = a;
    while( b != 0 ) 
    {
        if(b & 1)//判断最右边的位是否为1
            r *= base;
        base *= base; 
        b >>= 1;
    }
    return r;
}
```