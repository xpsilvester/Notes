# NodeJS 笔记

## Node简介

### 单线程

Node保持了JavaScript在浏览器中单线程的特点。

- 好处：不用像多线程编程那样需要在意状态的同步问题，没有死锁，也没有线程上下文交换的性能开销
- 弱点：1.无法利用多核CPU 2.错误会引起整个应用退出 3.大量计算占用CPU导致无法继续调用异步I/O

Node采用了与Web Worker相同的思路来解决单线程中大计算量的问题：`child_process`

### 应用场景

- I/O密集型

  I/O密集的优势主要在Node利用事件循环的处理能力，不是启动每一个线程为每一个请求服务，资源占用极少。

- CPU密集型

  由于单线程原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受并行异步I/O的好处，又能充分利用CPU。

Node虽然没有提供多线程用于计算，但是有两种方法可以充分利用CPU。

- 编写C/C++扩展的方式
- 通过子进程方式

## 模块机制

### Node的模块实现

在Node中引入模块，需要经历如下3个步骤：

- 路径分析，`require()`方法接受一个标识符作为参数。在Node实现中，正是基于这样一个标识符进行模块查找的。模块标识符主要分为以下几类：
  - 核心模块，如http、fs、path等
  - `.`或`..`开始的相对路径文件模块
  - 以`/`开始的绝对路径文件模块
  - 非路径形式的文件模块，如自定义的`connect`模块
- 文件定位
  - 文件扩展名分析：CommonJS模块规范允许在标识符不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补足扩展名，依次尝试
  - 目录分析和包：在分析标识符的过程中，`require()`通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当作一个包来处理。
- 编译执行，编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同扩展名的文件：
  - `.js`文件。通过fs模块同步读取文件后编译执行。
  - `.node`文件。这是用C/C++编写的扩展文件，通过`dlopen()`方法加载最后编译生成的文件。
  - `.json`文件。通过fs模块同步读取文件后，用`JSON.parse()`解析返回结果。
  - 其余扩展名文件。它们都被当成.js文件载入。

在Node中，模块分为两类：

- Node提供的模块，称为核心模块：在Node源代码编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。核心模块分为两类：
  - JavaScript核心模块
  - C/C++核心模块
- 用户编写的模块，称为文件模块：在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

### [模块化规范](https://juejin.im/post/6844903744518389768)

#### CommonJS，AMD，CMD区别

- CommonJS是用在服务器端的，同步的，如nodejs 
- AMD, CMD是用在浏览器端的，异步的，如requirejs和seajs 
- CommonJS： 每个文件就是一个模块，不用define进行定义，node使用此规范
- AMD： 使用define定义一个模块，讲究提前依赖
- CMD： 使用define定义模块，将就就近依赖

#### ES6中import和require区别

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
- ES6 模块的运行机制与 CommonJS 不一样。ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

#### exports 和 module.exports 的区别

- exports也是一个对象引用，它与module.exports默认指向同一个对象
- require引入的实际时module.exports，而如果对module.exports重新赋值时，就切断了它与原来对象的联系exports不会一起改变
- 通常使用exports = module.exports = somethings 修复，使它们指向同一个对象

### [雪崩问题](#利用事件队列解决雪崩问题)

#### 利用事件队列解决雪崩问题

雪崩问题就是在浏览器缓存失效后，并发访问量大量涌入数据库执行查询操作，导致数据库无法同时承受如此大的访问量，从而影响网站效果。

通过将请求的回调函数压入事件队列中来解决雪崩的办法，核心代码如下：

```JavaScript
var proxy = new EventProxy();
var status = "ready";
var select = function (callback) {
    proxy.once("selected", callback);
    if (status === "ready") {
        status = "pending";
        db.select("SQL", function (results) {
            proxy.emit("selected", results);
            status = "ready";
        });
    }
};
```